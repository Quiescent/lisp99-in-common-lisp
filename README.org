* Introduction

I'm learning Common Lisp and the Lisp-99 problems seem like a good way
to practice some of the basics.

* Problems

** [[./lisp/problem1.lisp][Problem 1]]: Find the last box of a list
Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem1.lisp")
  (my-last '(a b c d)); => (D)
#+END_SRC

#+RESULTS:
(D)

** [[./lisp/problem2.lisp][Problem 2]]: Find the last but one box of a list
Example

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem2.lisp")
  (my-but-last '(a b c d)); => (C D)
#+END_SRC

#+RESULTS:
(C D)

** [[./lisp/problem3.lisp][Problem 3]]: Find the K'th element of a list
The first element in the list is number 1.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem3.lisp")
  (element-at '(a b c d e) 3); => C
#+END_SRC

#+RESULTS:
C

** [[./lisp/problem4.lisp][Problem 4]]: Find the number of elements of a list

Example:
#+BEGIN_SRC lisp :results raw
  (load "lisp/problem4.lisp")
  (my-length '(1 2 3 4 5 6 7)); => 7
#+END_SRC

#+RESULTS:
7

** [[./lisp/problem5.lisp][Problem 5]]: Reverse a list

Example:
#+BEGIN_SRC lisp :results raw
  (load "lisp/problem5.lisp")
  (my-reverse '(a b c d e)); => (E D C B A)
  (my-reverse-2 '(a b c d e)); => (E D C B A)
#+END_SRC

#+RESULTS:
(E D C B A)

** [[./lisp/problem6.lisp][Problem 6]]: Find out whether a list is a palindrome

Example:
#+BEGIN_SRC lisp :results raw
  (load "lisp/problem6.lisp")
  (cons (is-palindrome '(1 2 3 4 5 6 7 8 9 10))
        (is-palindrome '(1 2 3 4 5 6 5 4 3 2 1))); => (NIL . T)
#+END_SRC

#+RESULTS:
(NIL . T)

** [[./lisp/problem7.lisp][Problem 7]]: Flatten a nested list structure
Transform a list, possibly holding lists as elements into a `flat'
list by replacing each list with its elements (recursively).

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem7.lisp")
  (my-flatten '(a (b (c d) e))); => (A B C D E)
#+END_SRC

#+RESULTS:
(A B C D E)

Hint: Use the predefined functions list and append.

** [[./lisp/problem8.lisp][Problem 8]]: Eliminate consecutive duplicates of list elements
If a list contains repeated elements they should be replaced with a
single copy of the element.  The order of the elements should not be
changed.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem8.lisp")
  (compress '(a a a a b c c a a d e e e e)); => (A B C A D E)
#+END_SRC

#+RESULTS:
(A B C A D E)

** [[./lisp/problem9.lisp][Problem 9]]: Pack consecutive duplicates of list elements into sublists
If a list contains repeated elements they should be placed in separate
sublists.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem9.lisp")
  (pack '(a a a a b c c a a d e e e e)); => ((A A A A) (B) (C C) (A A) (D) (E E E E))
#+END_SRC

#+RESULTS:
((A A A A) (B) (C C) (A A) (D) (E E E E))


** [[./lisp/problem10.lisp][Problem 10]]: Run-length encoding of a list
Use the result of problem P09 to implement the so-called run-length
encoding data compression method. Consecutive duplicates of elements
are encoded as lists (N E) where N is the number of duplicates of the
element E.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem9.lisp")
  (load "lisp/problem10.lisp")
  (encode '(a a a a b c c a a d e e e e)); => ((4 A) (1 B) (2 C) (2 A) (1 D) (4 E))
#+END_SRC

#+RESULTS:
((4 . A) (1 . B) (2 . C) (2 . A) (1 . D) (4 . E))

** [[./lisp/problem11.lisp][Problem 11]]: Modified run-length encoding
Modify the result of problem P10 in such a way that if an element has
no duplicates it is simply copied into the result list.  Only elements
with duplicates are transferred as (N E) lists.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem9.lisp")
  (load "lisp/problem10.lisp")
  (load "lisp/problem11.lisp").
  (encode-modified '(a a a a b c c a a d e e e e)); => ((4 A) B (2 C) (2 A) D (4 E))
#+END_SRC

#+RESULTS:
((4 . A) B (2 . C) (2 . A) D (4 . E))

** [[./lisp/problem12.lisp][Problem 12]]: Decode a run-length encoded list
Given a run-length code list generated as specified in problem
P11.  Construct its uncompressed version.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem12.lisp")
  (decode '((4 A) B (2 C) (2 A) D (4 E))); => (A A A A B C C A A D E E E E)
#+END_SRC

#+RESULTS:
(A A A A B C C A A D E E E E)

** [[./lisp/problem13.lisp][Problem 13]]: Run-length encoding of a list (direct solution)
Implement the so-called run-length encoding data compression method
directly.  I.e. don't explicitly create the sublists containing the
duplicates, as in problem P09, but only count them.  As in problem
P11, simplify the result list by replacing the singleton lists (1 X)
by X.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem13.lisp")
  (encode-direct '(a a a a b c c a a d e e e e)); => ((4 A) B (2 C) (2 A) D (4 E))
#+END_SRC

#+RESULTS:
((4 . A) B (2 . C) (2 . A) D (4 . E))

** [[./lisp/problem14.lisp][Problem 14]]: Duplicate the elements of a list

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem14.lisp")
  (dupli '(a b c c d)); => (A A B B C C C C D D)
#+END_SRC

#+RESULTS:
(A A B B C C C C D D)

** [[./lisp/problem15.lisp][Problem 15]]: Replicate the elements of a list a given number of times

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem15.lisp")
  (repli '(a b c) 3); => (A A A B B B C C C)
#+END_SRC

#+RESULTS:
(A A A B B B C C C)

** [[./lisp/problem16.lisp][Problem 16]]: Drop every N'th element from a list

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem16.lisp")
  (drop '(a b c d e f g h i k) 3); => (A B D E G H K)
#+END_SRC

#+RESULTS:
(A B D E G H K)

** [[./lisp/problem17.lisp][Problem 17]]: Split a list into two parts; the length of the first part is given
Do not use any predefined predicates.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem17.lisp")
  (split '(a b c d e f g h i k) 3); => ((A B C) (D E F G H I K))
#+END_SRC

#+RESULTS:
((A B C) ((D E F G H I K)))

** [[./lisp/problem18.lisp][Problem 18]]: Extract a slice from a list
Given two indices, I and K, the slice is the list containing the
elements between the I'th and K'th element of the original list (both
limits included).  Start counting the elements with 1.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem18.lisp")
  (slice '(a b c d e f g h i k) 3 7); => (C D E F G)
#+END_SRC

#+RESULTS:
(D E F G H)

** [[./lisp/problem19.lisp][Problem 19]]: Rotate a list N places to the left

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem19.lisp")
  (rotate '(a b c d e f g h) 3); => (D E F G H A B C)
#+END_SRC

#+RESULTS:
(D E F G H A B C)

** [[./lisp/problem20.lisp][Problem 20]]: Remove the K'th element from a list
Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem20.lisp")
  (remove-at '(a b c d) 2); => (A C D)
#+END_SRC

#+RESULTS:
(A C D)

** [[./lisp/problem21.lisp][Problem 21]]: Insert an element at a given position into a list

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem21.lisp")
  (insert-at 'alfa '(a b c d) 2); => (A ALFA B C D)
#+END_SRC

#+RESULTS:
(A ALFA B C D)

** [[./lisp/problem22.lisp][Problem 22]]: Create a list containing all integers within a given range
If first argument is smaller than second, produce a list in decreasing
order.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem22.lisp")
  (range 4 9); => (4 5 6 7 8 9)
#+END_SRC

#+RESULTS:
(4 5 6 7 8 9)

** [[./lisp/problem23.lisp][Problem 23]]: Extract a given number of randomly selected elements from a list
The selected items shall be returned in a list.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem23.lisp")
  (rnd-select '(a b c d e f g h) 3); => (E D A)
#+END_SRC

#+RESULTS:
(E B G)

** [[./lisp/problem24.lisp][Problem 24]]: Lotto: Draw N different random numbers from the set 1..M
The selected numbers shall be returned in a list.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem24.lisp")
  (lotto-select 6 49); => (23 1 17 33 21 37)
#+END_SRC

#+RESULTS:
(43 35 37 4 26 31)

** [[./lisp/problem25.lisp][Problem 25]]: Generate a random permutation of the elements of a list

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem25.lisp")
  (rnd-permu '(a b c d e f)); => (B A D C E F)
#+END_SRC

#+RESULTS:
(F B C E A D)

** [[./lisp/problem26.lisp][Problem 26]]: Generate the combinations of K distinct objects chosen from the N elements of a list
In how many ways can a committee of 3 be chosen from a group of 12
people? We all know that there are C(12,3) = 220 possibilities (C
(N,K) denotes the well-known binomial coefficients).  For pure
mathematicians, this result may be great.  But we want to really
generate all the possibilities in a list.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem26.lisp")
  (combination 3 '(a b c d e f)); => ((A B C) (A B D) (A B E) ... ) 
#+END_SRC

#+RESULTS:
((A B C) (A B D) (A B E) (A B F) (A C D) (A C E) (A C F) (A D E) (A D F)
 (A E F) (B C D) (B C E) (B C F) (B D E) (B D F) (B E F) (C D E) (C D F)
 (C E F) (D E F))

** [[./lisp/problem27.lisp][Problem 27]]: Group the elements of a set into disjoint subsets
a) In how many ways can a group of 9 people work in 3 disjoint
   subgroups of 2, 3 and 4 persons? Write a function that generates
   all the possibilities and returns them in a list.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem27.lisp")
  (group3 '(aldo beat carla david evi flip gary hugo ida)); => ( ( (ALDO BEAT) (CARLA DAVID EVI) (FLIP GARY HUGO IDA) ) ... )
#+END_SRC

#+RESULTS:

** [[./lisp/problem28.lisp][Problem 28]]: Sorting a list of lists according to length of sublists
a) We suppose that a list contains elements that are lists
   themselves.  The objective is to sort the elements of this list
   according to their length.  e.g. short lists first, longer lists
   later, or vice versa.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem28.lisp")
  (lsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o))); => ((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))
#+END_SRC

#+RESULTS:
((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))

** [[./lisp/problem29.lisp][Problem 29]]: Sorting a list of lists according to length of sublists
b) Again, we suppose that a list contains elements that are lists
   themselves.  But this time the objective is to sort the elements of
   this list according to their length frequency; i.e., in the
   default, where sorting is done ascendingly, lists with rare lengths
   are placed first, others with a more frequent length come later.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem29.lisp")
  (lfsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o))); => ((i j k l) (o) (a b c) (f g h) (d e) (d e) (m n))
#+END_SRC

#+RESULTS:
((I J K L) (O) (A B C) (F G H) (D E) (D E) (M N))

Note that in the above example, the first two lists in the result have
length 4 and 1, both lengths appear just once. The third and forth
list have length 3 which appears twice (there are two list of this
length).  And finally, the last three lists have length 2.  This is
the most frequent length.

** [[./lisp/problem30.lisp][Problem 30]]: Doesn't seem to exist??

** [[./lisp/problem31.lisp][Problem 31]]: Determine whether two positive integer numbers are coprime
Two numbers are coprime if their greatest common divisor equals 1.

Example:

#+BEGIN_SRC lisp :results raw
  (load "lisp/problem31.lisp")
  (coprime 35 64); => T
#+END_SRC

#+RESULTS:
T

** [[./lisp/problem32.lisp][Problem 32]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem33.lisp][Problem 33]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem34.lisp][Problem 34]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem35.lisp][Problem 35]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem36.lisp][Problem 36]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem37.lisp][Problem 37]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem38.lisp][Problem 38]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem39.lisp][Problem 39]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem40.lisp][Problem 40]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem41.lisp][Problem 41]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem42.lisp][Problem 42]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem43.lisp][Problem 43]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem44.lisp][Problem 44]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem45.lisp][Problem 45]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem46.lisp][Problem 46]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem47.lisp][Problem 47]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem48.lisp][Problem 48]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem49.lisp][Problem 49]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem50.lisp][Problem 50]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem51.lisp][Problem 51]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem52.lisp][Problem 52]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem53.lisp][Problem 53]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem54.lisp][Problem 54]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem55.lisp][Problem 55]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem56.lisp][Problem 56]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem57.lisp][Problem 57]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem58.lisp][Problem 58]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem59.lisp][Problem 59]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem60.lisp][Problem 60]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem61.lisp][Problem 61]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem62.lisp][Problem 62]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem63.lisp][Problem 63]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem64.lisp][Problem 64]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem65.lisp][Problem 65]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem66.lisp][Problem 66]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem67.lisp][Problem 67]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem68.lisp][Problem 68]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem69.lisp][Problem 69]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem70.lisp][Problem 70]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem71.lisp][Problem 71]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem72.lisp][Problem 72]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem73.lisp][Problem 73]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem74.lisp][Problem 74]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem75.lisp][Problem 75]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem76.lisp][Problem 76]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem77.lisp][Problem 77]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem78.lisp][Problem 78]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem79.lisp][Problem 79]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem80.lisp][Problem 80]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem81.lisp][Problem 81]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem82.lisp][Problem 82]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem83.lisp][Problem 83]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem84.lisp][Problem 84]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem85.lisp][Problem 85]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem86.lisp][Problem 86]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem87.lisp][Problem 87]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem88.lisp][Problem 88]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem89.lisp][Problem 89]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem90.lisp][Problem 90]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem91.lisp][Problem 91]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem92.lisp][Problem 92]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem93.lisp][Problem 93]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem94.lisp][Problem 94]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem95.lisp][Problem 95]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem96.lisp][Problem 96]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem97.lisp][Problem 97]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem98.lisp][Problem 98]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

** [[./lisp/problem99.lisp][Problem 99]]: {}
Example

#+BEGIN_SRC lisp :results raw

#+END_SRC

